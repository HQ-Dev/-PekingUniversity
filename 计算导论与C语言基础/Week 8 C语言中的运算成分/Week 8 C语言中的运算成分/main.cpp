//
//  main.cpp
//  Week 8 C语言中的运算成分
//
//  Created by apple on 15/12/8.
//  Copyright © 2015年 Archy. All rights reserved.
//

#include <iostream>
using namespace std;

int main(int argc, const char * argv[]) {
    
    // 第八周，将介绍C语言中的“运算成分”。重点在于：掌握各种运算符的基本含义，特别需要掌握“由各种运算符引起的数据类型转换的规律”
    
    // 第一课 第一节 "说在前面的话"
    /*
     C语言中的运算符范围很宽：
     & 求字节数运算符：  sizeof
     & 下标运算符： ［］
     & 赋值运算符：  =
     & 算数运算符：  + - * / %
     & 关系运算符： > < == >= <= !=
     & 逻辑运算符： ! && ||
     & 条件运算符： ? :
     & 逗号运算符： ,
     & 位运算符：   >> ~ | ^ &
     & 指针运算符： *, &
     & 强制类型转换运算符：  (类型)
     & 分量运算符： . ->
     
     C语言的运算符在各种语言中算是全面的了，但其实C++的运算符还要强大，甚至有可能强大大不是很好控制。
     
     */
    
    
    
    // 第一课 第二节 “赋值运算符”
    /*
     int a,b,c=5;
     表示只给c赋值。
     
     int a=b=c=5;
     上面这种赋值方式是不可以的！
     
     
               使用赋值运算符的一些要点
     要点一：两边的类型不同
       若 ＝ 两边的类型不一致，赋值的时候要进行类型转换；
       不管 ＝ 右边的操作数是什么类型，都要转换为 = 左边的类型
     */
    
//    int int_i = 64.12345;        // 右边会自动转换为整数64
//    char char_i = int_i;         // 输出@
//    float float_i = char_i;      // 会为char补充小数位： 64.0000     为什么会打印六位呢？因为cout在打印的时候是6位的精度
//    bool bool_i = float_i;       // 非零的数都是1，即 bool_i 的值就是 1;
//    cout<<showpoint<<int_i<<" "<<" "<<char_i<<" "<<float_i<<" "<<bool_i<< endl;
    
    // showpoint 的意思是什么呢？ 设置小数点模式，即使在不必要的时候也显示10进制小数点以及以后的0
    
    // 要点二： 长数赋给短数
    // 将会截取长数的低n位送给短数
    
//    char char_a = ' ';       // 8位                            01100001
//    int int_i = 0x361;       // 32位， 00000000000000000000001101100001
//    cout<<hex<<int_i<<endl;
//    char_a = int_i;    // 将长位赋给了短位
//    cout<<char_a<<endl;        // 输出的是a （代表的数字是97）
    
    
    // 举例：short = long
    // 00101010101010101010101010101010
    //                 1010101010101010          16位，第一位是1，则必然会输出一个负数
//    long int long_i = 0x2AAAAAAA;
//    cout<<long_i<<endl;
//    short short_j = long_i;
//    cout<<hex<<short_j<<endl;          // aaaa
//    cout<<dec<<short_j<<endl;          // -21846
    
    
    // 要点三： 短数赋给常熟
    // 最好的处理情况，原来是什么数，现在还是什么数！
    // short int a = -1;  int b = a;
    /*
     计算机的处理过程：
       若short型的数为无符号数：
         &short型16位到long型低16位，long型高16位补0；
       若short型为有符号数：
         &short型16位到long型低16位；
         &若short型最高位为0，则long型高16位补0；
         &若short型最高位为1，则long型高16位补1；
     */
    
//    short short_i = -123;
//    cout<<hex<<short_i<<endl;      // ff85
//    int int_j = short_i;
//    cout<<hex<<int_j<<endl;        // ffffff85
//    cout<<dec<<int_j<<endl;        // -123
    
    
    // 要点四：符号位的赋值情况处理
    //   &也很好处理的情况！直接搬运！
    //   &直接赋值，不管符号位还是数字位。
//    unsigned int unsigned_int_i = 0xAAAAAAA;
//    cout<<unsigned_int_i<<endl;      // 2863311530
//    signed int signed_int_j = unsigned_int_i;
//    cout<<hex<<signed_int_j<<endl;    // aaaaaaaa
//    cout<<dec<<signed_int_j<<endl;    //-1431655766
    
    // signed
    // 10101010101010101010101010101010
    // unsigned
    // 10101010101010101010101010101010
    
    
    
    // 第一课 第二节 “赋值运算说明”
    /*
     什么是表达式：
        程序中由运算符、操作数和括号组成的所组成的计算式，是计算求值的基本单位
     a*b+c;  123<10;   'a'*3.14f==1;   a=b;
     @表达式是有“值”的，赋值语句也不例外。（后面这句话的意思，看下面的代码）
     */
    
//    int i = 0;
//    cout<<(i=10)<<endl;     // 所以赋值语句也是有值的，它属于表达式，表达式都是有“值“的。
//    cout<<(i=i+i)<<endl;
    
    /*
              复合的赋值运算
     @在赋值符号前加上其他运算符号则构成复合赋值运算。
     @例如：
      a += 3;     等价于 a = a + 3;
      x *= y + 8;   等价于 x = x*(y + 8);
     */
    
    /*
            连续的赋值运算
     @自右向左的结合顺序
       a=b=c=5;   //a,b,c均为5
         int a=b=c=5;    // 编译错
     @a=(b=4)+(c=6);    //a为10，b为4，c为6；
     
     举例：
     a+=a-=a*a;   答案等于多少呢？   答案等于－264.
     先算a*a＝144,再算 a=a-144,a=-132,最后算 a+=-132,  等于－264
     
     能够被读懂的程序，才能被别人读懂，才能被长久的维护下去，你写的程序才会有更长的生命力
     */
    
    
    
    
    // 第二课 第一节 “算数运算”
    /*
     模运算，必须是整数
     整数运算，结果仍然是整数。
     ％模运算的优先级适合＊／相等的
     
     
     这节介绍了剪刀法求解复杂的表达式的值（各种不同的类型和运算符）
               计算过程中的类型转换
     double <--- float
        ^
        |
      long
        ^
        |
    unsigned                   ［相邻的类型进行计算的话，按左边的表进行转换再计算］
        ^
        |
       int <--- char,short
     
     */
    
    
    // 第二课 第二节  自增自减运算
    /*
     自增、自减运算符：使变量的值加1或者减1
       ＋＋i， －－i
          在使用i之前，先将i的值加（减）1
       i－－， i＋＋
          在使用i之后，再将i的值加（减）1
     
     例如：i的值是3，则
     j = ++i;   // j = 4
     j = i++;   // j = 3
     cout<<++i;
     cout<<i++;  // 先打印出3，但是i＝4
     
     cout<<-i++<<endl;     // 打印－3， i=4
     cout<<-++i<<endl;     // 打印－4
     cout<<(-i)++<<endl;    // 这样会编译错误，因为＋＋或者－－只能用于变量，不能用于表达式
     cout<<++i++<<endl;     // 在某些语言中成立，但是在c++中是不成立的，也是不能用于表达式了
     
     */
    
//    int a=0, b=0, c=2, d=0, e=2, f=2;
//    cout<<a<<" "<<a++<<" "<<endl;      // 预计输出：0 0        实际输出：0 0   但是在visual c++下 是1 0   （有同一个变量，会从右往左的顺序进行打印，so。。。）
//    cout<<++b<<" "<<b++<<" "<<endl;     // 预计输出：1 1         实际输出：1 1   但是vc 2 0
//    cout<<c<<" "<<(c++)+(++c)<<" "<<endl;     // 预计输出：2 6         实际输出：2 6   但是 vc 4 6
//    cout<<(d=f++)+(e=f)<<endl;          // 预计输出：5         实际输出：5    VC:4
//    cout<<f<<" "<<d<<" "<<e<<endl;      // 预计输出：3 2 3         实际输出：3 2 3    VC:3 2 2
//    int i = 0;

    
    
    // 第三课 第一节 关系运算
    // 关系运算表达式的值只能是1或者0
    // 优先级：算数运算符 > 系运算符 > 赋值运算符
    
    
    // 第三课 第二节 逻辑运算与混合运算
    /*
     若a=4,b=5，则a&&b的值为1
     */
    
    /*          逻辑运算符的优先级
     
        一个逻辑表达式中若包含多个逻辑运算符，则按一下的优先次序：
        ! --> && --> ||   即! 有最高的优先级
     
                混合运算的优先级
        逻辑非 ———》算数运算符 ————》关系运算符 ————》&& 和 || ————》赋值运算符
     
     
                逻辑运算的取舍
        逻辑表达式求解中，并不总是执行所有的运算
            只有在必须执行下一个逻辑运算符才能求出表达式的解时，才执行该运算符
     
     
     
                运算对象的扩展
        逻辑运算符两侧可以是任意类型
           如：字符型，实型或指针型等；
           系统最终以0和非零来判定它们，例如
                 ‘c’ && ‘d’
     
     */
    
    
    
    // 第四课 第一节 逗号，条件，强转
    /*
     再看一些其他的运算符，     逗号运算符合逗号表达式
     逗号运算符是用来连接表达式的：
       表达式1，表达式2，表达式3, ......表达式n       因为这也是一个表达式，所以只有一个值，就是最后一个表达式的值
       先求表达式1，再求表达式2，......,再求表达式n，整个表达式的值为表达式n的值
                    a = 3*5, a*4;     值最后是60，a=15
     
     
                        条件运算符
            表达式1？ 表达式2 ： 表达式3
     求值规律：
        如果表达式1为真，则以表达式2为条件表达式的值；否则以表达式3为条件表达式的值；
     
                    max = (a > b)? a : b;
       即如果 a>b为真，则max = a;否则max = b;
     
     
                        强制类型转换
     (double)a;      只是将值进行了转换
     (int)(x+y);
     (float)(5/3);
     注意！强制类型转换后，被转换的量的类型并没有发生变化。
     */
    
    
    
    // 第四课 第二节 位运算
    /*
     位运算：
         所谓的位运算就是指进行二进制位的运算。程序对内存进行操控的基本单位时字节，对二进制位进行运算，实际上也是通过以字节为单位的进行控制实现的。
     
     C++语言中的位运算符：（共六种）
        按位与（&）（即与运算）      双目运算符    （意思是有两个操作数参与的）
        按位或（｜） （即或运算）    双目运算符
        异或运算（^）              双目运算符
        取反运算（~）              单目运算符     （只有一个操作数参与）
        左移运算（<<）             单目运算符
        右移运算(>>)              单目运算符
     
       “按位与”运算符（&）
          参与运算的两个数据，各位均独立进行“与”运算。
        
        例如：对于表达式：a = 3 & 5, 有：
             3 = 00000011
         (&) 5 = 00000101
         ------------------
                 00000001        （其实1前面有31个零）
          因此，3 & 5 的值为：1
     
     
     
       “按位或”运算符（｜）
          参加运算的两个数据，各位均独立进行“或”运算。
     
        例如： 对于表达式： a = 3 | 5, 有：
           3 = 00000011
       (|) 5 = 00000101
       -----------------
               00000111
     因此，3｜5的值为：7
     
     
     
       “异或”运算符（^）
          异或运算符^也称XOR运算符。参加运算的两个数，各位均独立进行异或运算：
       
        即0 ^ 0 = 0; 0 ^ 1 = 1; 1 ^ 0 = 1; 1 ^ 1 = 0;
     例如：
     
          00111001   （十进制数57， 八进制数071）
      （^）00101010   （十进制数42， 八进制数052）
       ---------------------------------------
          00010011    (十进制数19， 八进制数023)
     
       即071^052， 结果为023（八进制数）。
     
     
     
         位运算符（4）
       取反运算符“～”是一个单目（元）运算符，用来对一个二进制数按位取反，
           即将0变1，1变0；
           例如：
               000000000010101
            （～）
               111111111101010
           因此，～（025）下标8的值为（177752）下标8
     
     
     
             左移运算符 （5）
       左移运算符（<<）
          用来将一个数的各二进位全部左移若干位；
          高位左移后溢出，舍弃不起作用；
          若a ＝ 15， 即二进制位00001111，左移2位得到00111100，即十进制数60
                a = a<<2;
          左移一位相当于该数乘以2，左移2位相当于该数乘以2的2次方＝ 4/
               只适用于该数左移时被溢出舍弃的高位中不包含1的情况。
     
            右移运算符（6）  与左移相同
     
            
            关于位运算的几个问题（1）
      右移运算符号位的处理
         对无符号数，右移时左边高位移入0；
         对于有符号的值，
             若原来符号位为0（该数为正），则左边移入0；
             若符号位原来为1（即负数），则左边移入0还是1，要取决于所用的计算机系统。   
                  若移入0，称为“逻辑右移”或“简单右移”
                  若移入1，称为“算数右移”（vc）
     
     
            关于位运算的几个问题（2）
     不同长度的数据进行位运算
         如果两个数据长度不同进行位运算时，系统会讲2者按右端对齐。
            如a&b,而a为int，b为short
         如何补位
            若果b为无符号整型数，则左侧添满0.
            如果b为有符号整数型：
                如果b为正数，则左侧16位补满0.
                如果b为负数，则左侧16位补满1.
     
     
                关于位运算的几个问题（3）
     位运算赋值运算符
         位运算符与赋值运算符可以组成符合赋值运算符如：&＝， ｜＝，>>=,<<=,^=
     
     
                关于位运算符的几个问题（4）
     算符优先级：
      取反运算符“～” －－》 算数运算符 －－》 左移<<右移>> －－》关系运算符－－》按位与&－－》按位异或^－－》按位或|－－》逻辑运算符
     
     
     关于位运算的应用这里不记笔记了，如用到请查找。
     
     */
    
    
    // 编程抄写题
    // 抄写题＃1:点评赛车
    /*
       描述：
         四名专家对四款赛车进行评论
        （1）a说：2号赛车时最好的；
        （2）b说：4号赛车时最好的；
        （3）c说：3号赛车不是最好的；
        （4）d说：b说错了。
         事实上只有一款赛车最佳，且只有1名专家说对了，其他3人都说错了。
       请编程输出最佳车的车号，以及说对的专家／
     
     输入： 无输入；
     输出：
         输出两行。第一行输出最佳车的车号（1-4中的某个数字）。第二行输出说对的专家（a-d中的某个字母）。
     */
    
    // 用 best 枚举最好的车
//    int best;
//    for (best = 1; best <= 4; best++)
//    {
//        bool a = (best == 2);
//        bool b = (best == 4);
//        bool c = !(best == 3);
//        bool d = !b;
//        if ((a + b + c + d) != 1)
//            continue;
//        cout << best << endl;
//        
//        // 接下来输出说对的专家
//        if (a == 1)
//            cout<<"A"<<endl;
//        else if (b == 1)
//            cout<<"B"<<endl;
//        else if (c == 1)
//            cout<<"C"<<endl;
//        else
//            cout<<"D"<<endl;
//    }
    
    
    return 0;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
