//
//  main.cpp
//  Week 7 课程笔记
//
//  Created by apple on 15/12/1.
//  Copyright © 2015年 Archy. All rights reserved.
//

#include <iostream>
#include <iomanip>
using namespace std;

int main(int argc, const char * argv[]) {

    /*
     第七周 C语言中的数据成分
     本周，我们将介绍C语言中的“数据成分”。重点在于：掌握各种数据类型在内存中所占的空间大小，掌握各种数据类型的特点。
     后面的学习还包括“运算成分”，“控制成分”，“传输成分”
     */
    
    // 第一课 第一节 “再谈学习进度与安排”
    
    // 第一课 第二节 “变量定义的含义”
    // 开讲数据成分
    // 想象内存的形式是一层层的袋子，每层有8个bit，形成一个内存单元，每个内存单元都对应一个内存地址（用16进制的字符表示一个地址，0x0012FF76）
    /*
     先了解什么是变量
     变量：先定义 才能使用（有些新语言不需要先定义）。    “值可以变化的量”
     变量的定义格式：
           （变量类型）   （变量标识符）
            int          Max;
            int          Max = 0;     定义变量的时候最好进行初始化，赋上一个值
            char         character;
            char         character = 'A';
            double       Result = 12.345;
     
     定义了变量之后会有什么影响呢？
     当计算机执行到此变量定义语句之后，会在内存空间中开辟一个连续的内存存储空间提供给此变量。
     
     那么我们可以在c++语言中定义哪些数据类型呢？
     
                                    布尔型（bool）
                                    字符型（char）
                    基本数据类型      整型  （int）            单精度型 （float）
                                    实型  （浮点型） ————>    双精度型 （double）
     
     
     C++的数据类型
                                    数组型 （类型［］）
                    自定义数据类型    指针型 （类型 *）           结构体型 （struct）
                                    构造数据类型   ——————>     联合体型 （union）
                                                             枚举型   （enum）
                                    类    （class）
                                    空类型 （void）
     */
    
    
    // 第三节 整数型的类别
    /*
     所谓整型数据就是存放整数类型的数据。
                                    基本型：int                                     32bit(位)   4byte(字节)
     在C++中，整数类型又被分成了三种 ——》短整型：short   or   short int   (前者为简写)     16bit      2byte
                                    长整型：long    or   long int                   32bit      4byte
     
     这三种分类是按它们所占的内存空间大小来决定的。
     [注]C标准没有具体规定以上各类数据所占的内存字节数，只要求long长度不短于int型，short型不长于int型。
     ——》这样就会造成在不同的编译平台，它们所占的字节数会不确定（不过基本上还是不用担心的）。
     
     那么如何可以知道自己所用的平台某种类型的数所占多少字节呢？
     ——》使用 sizeof 运算符！ 可知道任何数据类型所占字节数
     */
    
//    cout << sizeof(short) << endl;      //  2byte
//    cout << sizeof(long) << endl;       //  8byte
//    cout << sizeof(int) << endl;        //  4byte
    
    /*
     更加细分的划分，可以上面的三种整型 分别 分为 signed 和 unsigned
     */
    
    
    
    // 第二课 第一节 整数型的存储
    // 如果用 signed int i = -123 ， 在第一个内存单元中的第一位来表示正或者负数，1表示负数，0表示正。
    // 即－123被拆分为两部分来保存，其中 －号由第一位来表示，其他来表示123
    // 所以直观的印象，unsigned 可以表示更大的数
    
    // unsigned int i = 123    对于正整数存储原码，因为它的补码等于它的原码
    // |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|1|1|0|1|1|
    //
    //  123原码  <————>  取反 ＋ 1  <————>  －123补码
    //
    // signed int i = -123   对于负整数存储它的补码
    // |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|0|0|0|0|1|0|1|
    
    // 负数补码的求法
    /*
     signed int i = -123;
     1.先确定其符号位为1；
     2.求出其绝对值的原码：123 （符号位除外）
     |1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|1|1|0|1|1|
     
     3.对原码各位取反（符号位除外）
     |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|0|0|0|0|1|0|0|

     4.＋1
     |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|0|0|0|0|1|0|1|
     
    */
    
    
    // 第二课 第二节 整数的输入输出
    // 如何快速知道一个数的二进制表示时如何的呢？编写程序如果觉得太麻烦，可以用另一种方法，即打印一个数的十六进制表示
    // 例如 －123
    // |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|0|0|0|0|1|0|1|
    // 每四位表示一个十六进制显示，如下：
    // F  F  F  F  F  F  8  5     (如果你比较熟悉十六进制，就应该了解：F表示1111， 8表示1000, 5表示0101)  打印十六进制代码如下：
    
//    int a = -123;
//    cout << hex << a << endl;   // 打印结果是 ffffff85   hex是一个打印输出控制符
//    
//    // 某个数的八进制表示（三数合一）
//    cout << oct << a << endl;    // 结果是37777777605
//    
//    // 需要讲编译器调整为十进制的打印输出，免去可能会造成的输出误解
//    cout << dec << a << endl;
    
    // 那么如何在知道二进制数是什么的情况下，通过输入输出得到它的十进制数是什么呢？
    // 第一步将二进制数通过没四个数转换为八进制数的表现形式，然后将八进制数输入到程序当中
    // |0|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|0|0|0|0|1|0|1|  这个二进制数的八进制表示为：
    // 7  F  F  F  F  F  8  5    写在程序中为 0x7FFFFF85
    
//    int a = 0x7FFFFF85;        // 在系统中，只要一个数是 0x开头，系统就会将其理解为是16进制的数。以0开头的数，则会认为是8进制数
//    cout << dec << a << endl;
    
    
    // 第二课 第三节 最大和最小整数
    //  下面是最大整数
//    unsigned int a = 0xFFFFFFFF;
//    cout << dec << a << endl;
//    signed int  b = 0x7FFFFFFF;
//    cout << dec << b << endl;
//    
//    // 如何算最小整数呢？
//    cout << dec << b + 1 << endl;
    
    // signed int i = Max;
    // |0|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|
    // 上面的数加 1 就变成下面的表现形式
    // |1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|
    
    // 在C++中的解释，当最高位是1其他位为0（－0）时，最高位即表示负号，也表示整数最高位1. （此时1既表示符号位，又表示数字位）  结果为－2147483648
//    int a;
//    cout << a << endl;    // 虽然没有初始化a， 但是在xcode的环境下，a最后还是被自动赋上了0（不一定，也许只是恰好那个位置的内存是0而已，随机赋值maybe）.这个实验是要告诉我们注意对变量的初始化。
    
    
    
    // 第三课 第一节  浮点型
    // 浮点型也叫做实型
    // 浮点型          长度      有效位
    // float         32bit       7
    // double        64bit       15
    // long double   64bit       15
    
    // 理解一下什么是精度
//    float a = 3.141592654589793238464338327950288;
//    double b = 3.141592654589793238464338327950288;
//    long double c = 3.141592654589793238464338327950288;
    
//    cout << a << endl;
//    cout << b << endl;
//    cout << c << endl;
    // cout 输出一个浮点型的数字的时候，默认情况下输出一个六个有效位的数字
    // 调整 setprecision(100)
    
//    cout << setprecision(20) << a << endl;   // 注意项目前需要 导入<iomanip> ，即加头文件
//    cout << b << endl;
//    cout << c << endl;
    
    // 浮点数的表示
    // 32bit， 第一位中一位表示符号位，接下来8位表示指数位，剩下的23位用来表示二进制小数位。
    
    // float使用须知
//    float a = 0, b = 0;
//    a = 123456.789e5;
//    b = a + 20;
//    cout << setprecision(20) << b << endl;   // 输出的结果不准确，原因是要注意FLOAT的精度只有7位。
//    
    // 这个例子告诉我们，避免将一个很大的数和一个很小的数直接相加或者相减，否则就会“丢失”小的数
    
    
    // 第三课 第二节 字符型
    // 一个字符型占一个字节
    /*
       &其值可以是任何“可以出现在C/C++语言中的字符”；
       &最多可以表示为（256）个字符  ,因为一个字节可以保存的数字数量是2e8＝256   －－－－》所以这个字符集就是阿克斯码字符集！ ASCII Character Codes (美国标准信息交换码)
     
        例如 char a = '@'      @ <---> 64 <---> 01000000
     */
    
    // 使用须知：
    // 由于存储类型和整型相同，所以：
    // :字符型可以与整型数据相互赋值
    // :字符型可以和整数一样进行运算
//    char a = 64;
//    int b = 'Z';
//    int c = b - a;
////    char d = 6 + 256;       // 这个就超出限制255的限制了
//    cout << a << " " << b << " " << c << endl;
    // 注意字符数据中还有一种叫做转义字符。
    
    
    
    // 第三课 第三节 布尔型
    // 只占一个字节，字节是计算机程序所能控制的最小存储单位。
    // 其值只能为1（true）或者0（false）
    // 赋给布尔型变量的值：
    // 赋0存0，表示false
    // 赋非零存1，表示true，可以这样： bool a = "aString";
    
    
    // 第三课 第四节 常量
    // 什么是常量呢？
    /*
     常量：在程序运行的过程当中，它的值不会变化的量叫做常量
     
                 字面常量 ：  －1，0，123，4.6，－1.23
     常量 —————》
                 符号常量 ：  用一个标识符代表一个常量，称为符号常量
     */
    
//    const double PI = 3.14159;        // 符号常量需要在前面加关键字 const
//    float r, area;
//    cin >> r;
//    area = r * r * PI;
//    cout << "Area is " << area << endl;
    
    // 常量有类型吗？  —————— 答案当然是有的
    /*
      整型常量类型的后缀表示：
            n = 1000L;      // 长整型常量
            m = -0x88abL    // 长整型十六进制常量
            k = 10000U      // 无符号整型常量
            i = 07777LU     // 无符号长整型八进制常量
     
      浮点型常量的后缀表示：
            x = 3.1415F     // 单精度浮点型常量
            y = 3.1415L     // 长双精度浮点型常量
     
      说明：
            浮点型常量默认为double型；
            U,L,F均可以小写；
     */
    
    
    // 第三课 第五节 关于变量的命名
    // 关于给变脸命名是有规则的，要看是否合法。也称“标识符”
    /*
      什么是标识符？
         用来标识符号常量名、变量名、函数名、类型名、文件名的 “有效字符序列” 成为 “标识符”（identifier）.
     
         C++语言规定：标识符只能由字母、数字和下划线三种字符组成，并且第一个字符必须是字母或者下划线，且不可与保留字（关键字）相同。
         
         （由于我们现在是在C++的环境中进行编程，所以它保留字的数目是和 C语言不同的） 下面我列一下：
     
          asm          do               if          return         typedef
          auto         double           inline      short          typeid
          bool         dynamic_cast     int         signed         typename
          break        else             long        sizeof         union
          case         enum             mutable     stitic         unsigned
          catch        explicit         namespace   static_cast    using
          char         export           new         struct         virtual
          class        extern           operator    switch         void
          const        false            private     template       volatile
          const_cast   float            protected   this           wchar_t
          continue     for              public      throw          while
          default      friend           register    true           delete
          goto         reinterpret_cast try
     
     
     
     关于变量如何更好地命名有很多中说法，下面介绍几种最重要的：
     
        匈牙利命名法：（Charles Simonyi）
                  1.以一个或者多个小写字母开头，来 “指定数据类型 ”。
                  2.其后是一个或者多个第一个字母大写的单词，来指出变量的用途。
                  例如：chGrade; nLength; bOnOff; strStudentName;
     
        
        驼峰命名法：
                由一个或者多个单词连结在一起；
                第一个单词以小写字母开始；
                第二个单词的首字母大写或者每一个单词的首字母都大写；
                例如：myFirstName, myLastName;
       
        正确的观念：其实对于命名法不用太执着和固执，合适的地方就使用适合的命名法，同时可以创造自己的一种独特命名方式。
     
     
     */
    
    return 0;







    
    
    

}
